{"version":3,"sources":["components/Map.js","App.js","index.js"],"names":["calculateClosestCountries","currentCountry","geographies","countryColors","destinationCountry","currentCentroid","geoCentroid","distances","filter","geo","properties","name","undefined","map","distance","geoDistance","sort","a","b","slice","Map","setCountryColors","useState","zoomCenter","setZoomCenter","coordinates","zoom","setDestinationCountry","useEffect","geoJson","feature","worldCountries","objects","countries","randomCountry","features","Math","floor","random","length","destination","console","error","centroid","prevColors","newColors","forEach","country","_jsx","ComposableMap","id","children","_jsxs","ZoomableGroup","center","Geographies","geography","_ref","countryColor","Geography","className","onClick","handleCountryClick","userGuess","prompt","isCorrect","toLowerCase","alert","Object","keys","countryName","style","default","fill","outline","hover","opacity","rsmKey","_ref2","projection","x","y","React","Fragment","width","height","rx","ry","pointerEvents","textAnchor","fontFamily","fontSize","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1d3d1ddb.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { ComposableMap, Geographies, Geography, ZoomableGroup } from 'react-simple-maps';\nimport { geoCentroid, geoDistance } from 'd3-geo';\nimport { feature } from 'topojson-client';\nimport worldCountries from '../topojson/world-countries.json'; // Adjust the path as needed\n\nconst calculateClosestCountries = (currentCountry, geographies, countryColors, destinationCountry) => {\n  // Get the centroid of the current country\n  const currentCentroid = geoCentroid(currentCountry);\n\n  // Calculate distances to all other countries, including the destination country\n  const distances = geographies\n    .filter(\n      (geo) =>\n        geo.properties.name !== currentCountry.properties.name && // Exclude the current country\n        (countryColors[geo.properties.name] === '#808080' || // Include grey countries\n         countryColors[geo.properties.name] === undefined || // Include unguessed countries\n         (destinationCountry && geo.properties.name === destinationCountry.properties.name)) // Include the destination country\n    )\n    .map((geo) => ({\n      name: geo.properties.name,\n      distance: geoDistance(currentCentroid, geoCentroid(geo)), // Calculate distance\n    }));\n\n  // Sort by distance (ascending)\n  distances.sort((a, b) => a.distance - b.distance);\n\n  // Return the closest 4 countries\n  return distances.slice(0, 4);\n};\n\nconst Map = () => {\n  const [countryColors, setCountryColors] = useState({}); // Track colors for each country\n  const [zoomCenter, setZoomCenter] = useState({ coordinates: [0, 0], zoom: 1 }); // Center and zoom level\n  const [destinationCountry, setDestinationCountry] = useState(null); // Track the destination country\n\n  const handleCountryClick = (geo, geographies) => {\n    // Allow guessing only for yellow or pink countries\n    if (countryColors[geo.properties.name] !== '#f1c232' && countryColors[geo.properties.name] !== '#f999ac') {\n      return; // Do nothing if the country is not yellow or pink\n    }\n\n    const userGuess = prompt(`What is the name of this country?`);\n    const isCorrect = userGuess && userGuess.toLowerCase() === geo.properties.name.toLowerCase();\n\n    setCountryColors((prevColors) => {\n      const newColors = { ...prevColors };\n      if (userGuess === null) {\n        return newColors; // Do nothing if the user cancels the prompt\n      }\n\n      if (isCorrect) {\n        // Check if the guessed country is the destination country\n        if (geo.properties.name === destinationCountry.properties.name) {\n          alert('Congratulations! You reached the destination country and won the game!');\n        }\n\n        // If the guess is correct, reset previously highlighted closest countries\n        Object.keys(newColors).forEach((countryName) => {\n          if (newColors[countryName] === '#f1c232') {\n            newColors[countryName] = '#808080'; // Reset to grey\n          }\n        });\n        // Set the clicked country's color\n        newColors[geo.properties.name] = '#6aa84f'; // Medium green for correct guess\n\n        // recaclulate the closest countries (onlu on correcct guess)\n        const closestCountries = calculateClosestCountries(geo, geographies, prevColors, destinationCountry);\n\n        closestCountries.forEach((country) => {\n          if (destinationCountry && country.name === destinationCountry.properties.name) {\n            newColors[country.name] = '#f999ac'; // Make the destination country pink\n          } else {\n            newColors[country.name] = '#f1c232'; // Highlight the closest countries in yellow\n          }\n        });\n      }\n      else {\n        // Set the clicked country's color to red for incorrect guesses\n        newColors[geo.properties.name] = '#cc0000'; // Red for incorrect guess\n      }\n\n      return newColors;\n    });\n  };\n\n  useEffect(() => {\n    // Convert TopoJSON to GeoJSON\n    const geoJson = feature(worldCountries, worldCountries.objects.countries);\n\n    // Randomly select a country from the GeoJSON features\n    const randomCountry = geoJson.features[Math.floor(Math.random() * geoJson.features.length)];\n    const destination = geoJson.features[Math.floor(Math.random() * geoJson.features.length)];\n\n    if (!randomCountry || !destination) {\n      console.error(\"No countries found in the GeoJSON data.\");\n      return;\n    }\n\n    const centroid = geoCentroid(randomCountry); // Get the centroid of the random country\n\n    setCountryColors((prevColors) => {\n      const newColors = { ...prevColors };\n\n      // Mark the randomly selected country as guessed correctly\n      newColors[randomCountry.properties.name] = '#6aa84f'; // Medium green\n\n      // Mark the destination country as purple\n      newColors[destination.properties.name] = '#800080'; // Purple for the destination country\n\n      // Calculate the closest 4 countries\n      const closestCountries = calculateClosestCountries(randomCountry, geoJson.features, prevColors, destination);\n\n      // Highlight the closest 4 countries in yellow\n      closestCountries.forEach((country) => {\n        newColors[country.name] = '#f1c232';\n      });\n\n      return newColors;\n    });\n\n    // Set the destination country\n    setDestinationCountry(destination);\n\n    // Set the map to zoom in on the randomly selected country\n    setZoomCenter({ coordinates: centroid, zoom: 4 });\n  }, []);\n\n  return (\n    <ComposableMap id=\"map\">\n      <ZoomableGroup center={zoomCenter.coordinates} zoom={zoomCenter.zoom}>\n        {/* Render countries */}\n        <Geographies geography={feature(worldCountries, worldCountries.objects.countries)}>\n          {({ geographies }) =>\n            geographies.map((geo) => {\n              const countryColor = countryColors[geo.properties.name] || '#808080'; // Default to grey\n\n              return (\n                <Geography\n                  key={geo.rsmKey}\n                  geography={geo}\n                  className=\"country\"\n                  onClick={() => handleCountryClick(geo, geographies)}\n                  style={{\n                    default: { fill: countryColor, outline: 'none' },\n                    hover: { fill: countryColor, opacity: 0.7 },\n                  }}\n                />\n              );\n            })\n          }\n        </Geographies>\n\n        {/* Render country names and white rectangles on top */}\n        <Geographies geography={feature(worldCountries, worldCountries.objects.countries)}>\n          {({ geographies, projection }) =>\n            geographies.map((geo) => {\n              const countryColor = countryColors[geo.properties.name];\n\n              // Skip rendering names for yellow, grey, or the destination country\n              if (\n                !countryColor || // Skip unguessed countries\n                countryColor === '#f1c232' || // Yellow\n                countryColor === '#808080' || // Grey\n                (destinationCountry && geo.properties.name === destinationCountry.properties.name) // Destination country\n              ) {\n                return null;\n              }\n              \n              const centroid = geoCentroid(geo); // Calculate the centroid of the country\n              const [x, y] = projection(centroid); // Convert geographic coordinates to screen coordinates\n\n              return (\n                <React.Fragment key={geo.rsmKey}>\n                  {/* Render a white rectangle behind the text */}\n                  <rect\n                    x={x - geo.properties.name.length - 2} // Reduce padding on the left\n                    y={y} // Reduce padding on the top\n                    width={geo.properties.name.length * 2 + 4} // Reduce overall width\n                    height={6} // Reduce height\n                    fill=\"white\"\n                    rx={3} // Slightly smaller rounded corners\n                    ry={3}\n                    style={{\n                      pointerEvents: 'none', // Ensure the rectangle doesn't block clicks\n                    }}\n                  />\n                  {/* Render the country name */}\n                  <text\n                    x={x}\n                    y={y + 4} // Adjust to vertically center the text\n                    textAnchor=\"middle\"\n                    style={{\n                      fontFamily: 'Arial, sans-serif',\n                      fontSize: 10 / zoomCenter.zoom, // Adjust font size inversely to zoom\n                      fill: '#000',\n                      pointerEvents: 'none', // Ensure the text doesn't block clicks\n                    }}\n                  >\n                    {geo.properties.name}\n                  </text>\n                </React.Fragment>\n              );\n            })\n          }\n        </Geographies>\n      </ZoomableGroup>\n    </ComposableMap>\n  );\n};\n\nexport default Map;","import React from 'react';\nimport Map from './components/Map';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Map />\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}