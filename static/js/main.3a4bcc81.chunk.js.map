{"version":3,"sources":["components/Map.js","App.js","index.js"],"names":["calculateClosestCountries","currentCountry","geographies","countryColors","destinationCountry","currentCountryName","properties","name","neighbors","currentCountryNeighbors","Object","keys","console","log","filter","country","undefined","currentCentroid","geoCentroid","distances","geo","map","distance","geoDistance","sort","a","b","closestCountries","slice","Map","setCountryColors","useState","zoomCenter","setZoomCenter","coordinates","zoom","setDestinationCountry","useEffect","geoJson","feature","worldCountries","objects","countries","randomCountry","features","Math","floor","random","length","destination","error","centroid","prevColors","newColors","forEach","_jsx","ComposableMap","id","children","_jsxs","ZoomableGroup","center","Geographies","geography","_ref","countryColor","Geography","className","onClick","handleCountryClick","userGuess","prompt","isCorrect","toLowerCase","alert","countryName","JSON","stringify","style","default","fill","outline","hover","opacity","rsmKey","_ref2","projection","x","y","React","Fragment","width","height","rx","ry","pointerEvents","textAnchor","fontFamily","fontSize","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3a4bcc81.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { ComposableMap, Geographies, Geography, ZoomableGroup } from 'react-simple-maps';\nimport { geoCentroid, geoDistance } from 'd3-geo';\nimport { feature } from 'topojson-client';\nimport worldCountries from '../data/world-countries.json';\nimport neighbors from '../data/neighbors.json';\n\nconst calculateClosestCountries = (currentCountry, geographies, countryColors, destinationCountry) => {\n\n  const currentCountryName = currentCountry.properties.name;\n  if (neighbors[currentCountryName])\n  {\n    var currentCountryNeighbors = Object.keys(neighbors[currentCountryName])\n    console.log(`All neighbors for ${currentCountryName}: ${currentCountryNeighbors}`);\n\n    currentCountryNeighbors = currentCountryNeighbors.filter(\n      (country) =>\n        (countryColors[country] === '#808080' || // Include grey countries\n        countryColors[country] === undefined || // Include unguessed countries\n        (destinationCountry && country === destinationCountry.properties.name)) // Include the destination country\n        \n    )\n    \n    console.log(`Filtered neighbors for ${currentCountryName}: ${currentCountryNeighbors}`);\n    return currentCountryNeighbors; // might get less then 4 countries\n  }\n\n  console.log(`Finding closest countries for ${currentCountryName}`);\n  // Get the centroid of the current country\n  const currentCentroid = geoCentroid(currentCountry);\n\n  // Calculate distances to all other countries, including the destination country\n  const distances = geographies\n    .filter(\n      (geo) =>\n        geo.properties.name !== currentCountryName && // Exclude the current country\n        (countryColors[geo.properties.name] === '#808080' || // Include grey countries\n         countryColors[geo.properties.name] === undefined || // Include unguessed countries\n         (destinationCountry && geo.properties.name === destinationCountry.properties.name)) // Include the destination country\n    )\n    .map((geo) => ({\n      name: geo.properties.name,\n      distance: geoDistance(currentCentroid, geoCentroid(geo)), // Calculate distance\n    }));\n\n  // Sort by distance (ascending)\n  distances.sort((a, b) => a.distance - b.distance);\n\n  var closestCountries = distances.slice(0, 4).map((country) => country.name );\n  \n  console.log(`Closest countries are: ${closestCountries}`);\n\n  // Return the closest 4 countries\n  return closestCountries;\n};\n\nconst Map = () => {\n  const [countryColors, setCountryColors] = useState({}); // Track colors for each country\n  const [zoomCenter, setZoomCenter] = useState({ coordinates: [0, 0], zoom: 1 }); // Center and zoom level\n  const [destinationCountry, setDestinationCountry] = useState(null); // Track the destination country\n\n  const handleCountryClick = (geo, geographies) => {\n    // Allow guessing only for yellow or pink countries\n    if (countryColors[geo.properties.name] !== '#f1c232' && countryColors[geo.properties.name] !== '#f999ac') {\n      return; // Do nothing if the country is not yellow or pink\n    }\n\n    const userGuess = prompt(`What is the name of this country?`);\n    const isCorrect = userGuess && userGuess.toLowerCase() === geo.properties.name.toLowerCase();\n\n    setCountryColors((prevColors) => {\n      const newColors = { ...prevColors };\n      if (userGuess === null) {\n        return newColors; // Do nothing if the user cancels the prompt\n      }\n\n      if (isCorrect) {\n        // Check if the guessed country is the destination country\n        if (geo.properties.name === destinationCountry.properties.name) {\n          alert('Congratulations! You reached the destination country and won the game!');\n        }\n\n        // If the guess is correct, reset previously highlighted closest countries\n        Object.keys(newColors).forEach((countryName) => {\n          if (newColors[countryName] === '#f1c232') {\n            newColors[countryName] = '#808080'; // Reset to grey\n          }\n        });\n        // Set the clicked country's color\n        newColors[geo.properties.name] = '#6aa84f'; // Medium green for correct guess\n\n        // recaclulate the closest countries (onlu on correcct guess)\n        const closestCountries = calculateClosestCountries(geo, geographies, newColors, destinationCountry);\n\n        closestCountries.forEach((country) => {\n          if (destinationCountry && country === destinationCountry.properties.name) {\n            newColors[country] = '#f999ac'; // Make the destination country pink\n          } else {\n            newColors[country] = '#f1c232'; // Highlight the closest countries in yellow\n          }\n        });\n      }\n      else {\n        // Set the clicked country's color to red for incorrect guesses\n        newColors[geo.properties.name] = '#cc0000'; // Red for incorrect guess\n      }\n      console.log(JSON.stringify(newColors));\n      return newColors;\n    });\n  };\n\n  useEffect(() => {\n    // Convert TopoJSON to GeoJSON\n    const geoJson = feature(worldCountries, worldCountries.objects.countries);\n\n    // Randomly select a country from the GeoJSON features\n    const randomCountry = geoJson.features[Math.floor(Math.random() * geoJson.features.length)];\n    const destination = geoJson.features[Math.floor(Math.random() * geoJson.features.length)];\n\n    if (!randomCountry || !destination) {\n      console.error(\"No countries found in the GeoJSON data.\");\n      return;\n    }\n\n    const centroid = geoCentroid(randomCountry); // Get the centroid of the random country\n\n    setCountryColors((prevColors) => {\n      const newColors = { ...prevColors };\n\n      // Mark the randomly selected country as guessed correctly\n      newColors[randomCountry.properties.name] = '#6aa84f'; // Medium green\n\n      // Mark the destination country as purple\n      newColors[destination.properties.name] = '#800080'; // Purple for the destination country\n\n      // Calculate the closest 4 countries\n      const closestCountries = calculateClosestCountries(randomCountry, geoJson.features, newColors, destination);\n\n      // Highlight the closest 4 countries in yellow\n      closestCountries.forEach((country) => {\n        newColors[country] = '#f1c232';\n      });\n\n      return newColors;\n    });\n\n    // Set the destination country\n    setDestinationCountry(destination);\n\n    // Set the map to zoom in on the randomly selected country\n    setZoomCenter({ coordinates: centroid, zoom: 4 });\n  }, []);\n\n  return (\n    <ComposableMap id=\"map\">\n      <ZoomableGroup center={zoomCenter.coordinates} zoom={zoomCenter.zoom}>\n        {/* Render countries */}\n        <Geographies geography={feature(worldCountries, worldCountries.objects.countries)}>\n          {({ geographies }) =>\n            geographies.map((geo) => {\n              const countryColor = countryColors[geo.properties.name] || '#808080'; // Default to grey\n\n              return (\n                <Geography\n                  key={geo.rsmKey}\n                  geography={geo}\n                  className=\"country\"\n                  onClick={() => handleCountryClick(geo, geographies)}\n                  style={{\n                    default: { fill: countryColor, outline: 'none' },\n                    hover: { fill: countryColor, opacity: 0.7 },\n                  }}\n                />\n              );\n            })\n          }\n        </Geographies>\n\n        {/* Render country names and white rectangles on top */}\n        <Geographies geography={feature(worldCountries, worldCountries.objects.countries)}>\n          {({ geographies, projection }) =>\n            geographies.map((geo) => {\n              const countryColor = countryColors[geo.properties.name];\n\n              // Skip rendering names for yellow, grey, or the destination country\n              if (\n                !countryColor || // Skip unguessed countries\n                countryColor === '#f1c232' || // Yellow\n                countryColor === '#808080' || // Grey\n                (destinationCountry && geo.properties.name === destinationCountry.properties.name) // Destination country\n              ) {\n                return null;\n              }\n              \n              const centroid = geoCentroid(geo); // Calculate the centroid of the country\n              const [x, y] = projection(centroid); // Convert geographic coordinates to screen coordinates\n\n              return (\n                <React.Fragment key={geo.rsmKey}>\n                  {/* Render a white rectangle behind the text */}\n                  <rect\n                    x={x - geo.properties.name.length - 2} // Reduce padding on the left\n                    y={y} // Reduce padding on the top\n                    width={geo.properties.name.length * 2 + 4} // Reduce overall width\n                    height={6} // Reduce height\n                    fill=\"white\"\n                    rx={3} // Slightly smaller rounded corners\n                    ry={3}\n                    style={{\n                      pointerEvents: 'none', // Ensure the rectangle doesn't block clicks\n                    }}\n                  />\n                  {/* Render the country name */}\n                  <text\n                    x={x}\n                    y={y + 4} // Adjust to vertically center the text\n                    textAnchor=\"middle\"\n                    style={{\n                      fontFamily: 'Arial, sans-serif',\n                      fontSize: 10 / zoomCenter.zoom, // Adjust font size inversely to zoom\n                      fill: '#000',\n                      pointerEvents: 'none', // Ensure the text doesn't block clicks\n                    }}\n                  >\n                    {geo.properties.name}\n                  </text>\n                </React.Fragment>\n              );\n            })\n          }\n        </Geographies>\n      </ZoomableGroup>\n    </ComposableMap>\n  );\n};\n\nexport default Map;","import React from 'react';\nimport Map from './components/Map';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Map />\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}