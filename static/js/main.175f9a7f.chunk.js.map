{"version":3,"sources":["components/Map.js","assets/background.png","components/StartScreen.js","App.js","index.js"],"names":["calculateClosestCountries","currentCountry","geographies","countryColors","destinationCountry","currentCountryName","properties","name","neighbors","currentCountryNeighbors","Object","keys","console","log","filter","country","undefined","currentCentroid","geoCentroid","distances","geo","map","distance","geoDistance","sort","a","b","closestCountries","slice","Map","setCountryColors","useState","zoomCenter","setZoomCenter","coordinates","zoom","setDestinationCountry","useEffect","geoJson","feature","worldCountries","objects","countries","randomCountry","features","Math","floor","random","length","destination","error","centroid","prevColors","newColors","forEach","_jsx","ComposableMap","id","children","_jsxs","ZoomableGroup","center","Geographies","geography","_ref","countryColor","Geography","className","onClick","async","value","userGuess","Swal","fire","title","input","inputLabel","inputPlaceholder","showCancelButton","confirmButtonText","inputValidator","isCorrect","toLowerCase","icon","text","confirmButtonColor","countryName","JSON","stringify","handleCountryClick","style","default","fill","outline","hover","opacity","rsmKey","_ref2","projection","x","y","React","Fragment","width","height","rx","ry","pointerEvents","textAnchor","fontFamily","fontSize","StartScreen","onStart","display","flexDirection","justifyContent","alignItems","backgroundImage","background","backgroundSize","backgroundPosition","backgroundColor","color","padding","border","borderRadius","cursor","App","started","setStarted","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.175f9a7f.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { ComposableMap, Geographies, Geography, ZoomableGroup } from 'react-simple-maps';\nimport { geoCentroid, geoDistance } from 'd3-geo';\nimport { feature } from 'topojson-client';\nimport worldCountries from '../data/world-countries.json';\nimport neighbors from '../data/neighbors.json';\nimport Swal from 'sweetalert2';\n\nconst calculateClosestCountries = (currentCountry, geographies, countryColors, destinationCountry) => {\n\n  const currentCountryName = currentCountry.properties.name;\n  if (neighbors[currentCountryName]) {\n    var currentCountryNeighbors = Object.keys(neighbors[currentCountryName])\n    console.log(`All neighbors for ${currentCountryName}: ${currentCountryNeighbors}`);\n\n    currentCountryNeighbors = currentCountryNeighbors.filter(\n      (country) =>\n      (countryColors[country] === '#808080' || // Include grey countries\n        countryColors[country] === undefined || // Include unguessed countries\n        (destinationCountry && country === destinationCountry.properties.name)) // Include the destination country\n\n    )\n\n    console.log(`Filtered neighbors for ${currentCountryName}: ${currentCountryNeighbors}`);\n    return currentCountryNeighbors; // might get less then 4 countries\n  }\n\n  console.log(`Finding closest countries for ${currentCountryName}`);\n  // Get the centroid of the current country\n  const currentCentroid = geoCentroid(currentCountry);\n\n  // Calculate distances to all other countries, including the destination country\n  const distances = geographies\n    .filter(\n      (geo) =>\n        geo.properties.name !== currentCountryName && // Exclude the current country\n        (countryColors[geo.properties.name] === '#808080' || // Include grey countries\n          countryColors[geo.properties.name] === undefined || // Include unguessed countries\n          (destinationCountry && geo.properties.name === destinationCountry.properties.name)) // Include the destination country\n    )\n    .map((geo) => ({\n      name: geo.properties.name,\n      distance: geoDistance(currentCentroid, geoCentroid(geo)), // Calculate distance\n    }));\n\n  // Sort by distance (ascending)\n  distances.sort((a, b) => a.distance - b.distance);\n\n  var closestCountries = distances.slice(0, 4).map((country) => country.name);\n\n  console.log(`Closest countries are: ${closestCountries}`);\n\n  // Return the closest 4 countries\n  return closestCountries;\n};\n\nconst Map = () => {\n  const [countryColors, setCountryColors] = useState({}); // Track colors for each country\n  const [zoomCenter, setZoomCenter] = useState({ coordinates: [0, 0], zoom: 1 }); // Center and zoom level\n  const [destinationCountry, setDestinationCountry] = useState(null); // Track the destination country\n\n  const handleCountryClick = async (geo, geographies) => {\n    // Allow guessing only for yellow or pink countries\n    if (countryColors[geo.properties.name] !== '#f1c232' && countryColors[geo.properties.name] !== '#f999ac') {\n      return; // Do nothing if the country is not yellow or pink\n    }\n\n    const { value: userGuess } = await Swal.fire({\n      title: 'Guess the Country',\n      input: 'text',\n      inputLabel: 'What is the name of this country?',\n      inputPlaceholder: 'Enter country name',\n      showCancelButton: true,\n      confirmButtonText: 'Submit',\n      inputValidator: (value) => {\n        if (!value) {\n          return 'You need to write something!';\n        }\n        return null;\n      },\n    });\n    const isCorrect = userGuess && userGuess.toLowerCase() === geo.properties.name.toLowerCase();\n\n    setCountryColors((prevColors) => {\n      const newColors = { ...prevColors };\n      if (userGuess === null) {\n        return newColors; // Do nothing if the user cancels the prompt\n      }\n\n      if (isCorrect) {\n        // Check if the guessed country is the destination country\n        if (geo.properties.name === destinationCountry.properties.name) {\n          Swal.fire({\n            icon: 'success',\n            title: 'Congratulations!',\n            text: 'You reached the destination country and won the game!',\n            confirmButtonColor: '#6aa84f',\n          });\n        }\n\n        // If the guess is correct, reset previously highlighted closest countries\n        Object.keys(newColors).forEach((countryName) => {\n          if (newColors[countryName] === '#f1c232') {\n            newColors[countryName] = '#808080'; // Reset to grey\n          }\n        });\n        // Set the clicked country's color\n        newColors[geo.properties.name] = '#6aa84f'; // Medium green for correct guess\n\n        // recaclulate the closest countries (onlu on correcct guess)\n        const closestCountries = calculateClosestCountries(geo, geographies, newColors, destinationCountry);\n\n        closestCountries.forEach((country) => {\n          if (destinationCountry && country === destinationCountry.properties.name) {\n            newColors[country] = '#f999ac'; // Make the destination country pink\n          } else {\n            newColors[country] = '#f1c232'; // Highlight the closest countries in yellow\n          }\n        });\n      }\n      else {\n        // Set the clicked country's color to red for incorrect guesses\n        newColors[geo.properties.name] = '#cc0000'; // Red for incorrect guess\n      }\n      console.log(JSON.stringify(newColors));\n      return newColors;\n    });\n  };\n\n  useEffect(() => {\n    // Convert TopoJSON to GeoJSON\n    const geoJson = feature(worldCountries, worldCountries.objects.countries);\n\n    // Randomly select a country from the GeoJSON features\n    const randomCountry = geoJson.features[Math.floor(Math.random() * geoJson.features.length)];\n    const destination = geoJson.features[Math.floor(Math.random() * geoJson.features.length)];\n\n    if (!randomCountry || !destination) {\n      console.error(\"No countries found in the GeoJSON data.\");\n      return;\n    }\n\n    const centroid = geoCentroid(randomCountry); // Get the centroid of the random country\n\n    setCountryColors((prevColors) => {\n      const newColors = { ...prevColors };\n\n      // Mark the randomly selected country as guessed correctly\n      newColors[randomCountry.properties.name] = '#6aa84f'; // Medium green\n\n      // Mark the destination country as purple\n      newColors[destination.properties.name] = '#800080'; // Purple for the destination country\n\n      // Calculate the closest 4 countries\n      const closestCountries = calculateClosestCountries(randomCountry, geoJson.features, newColors, destination);\n\n      // Highlight the closest 4 countries in yellow\n      closestCountries.forEach((country) => {\n        newColors[country] = '#f1c232';\n      });\n\n      return newColors;\n    });\n\n    // Set the destination country\n    setDestinationCountry(destination);\n\n    // Set the map to zoom in on the randomly selected country\n    setZoomCenter({ coordinates: centroid, zoom: 4 });\n  }, []);\n\n  return (\n    <ComposableMap id=\"map\">\n      <ZoomableGroup center={zoomCenter.coordinates} zoom={zoomCenter.zoom}>\n        {/* Render countries */}\n        <Geographies geography={feature(worldCountries, worldCountries.objects.countries)}>\n          {({ geographies }) =>\n            geographies.map((geo) => {\n              const countryColor = countryColors[geo.properties.name] || '#808080'; // Default to grey\n\n              return (\n                <Geography\n                  key={geo.rsmKey}\n                  geography={geo}\n                  className=\"country\"\n                  onClick={() => handleCountryClick(geo, geographies)}\n                  style={{\n                    default: { fill: countryColor, outline: 'none' },\n                    hover: { fill: countryColor, opacity: 0.7 },\n                  }}\n                />\n              );\n            })\n          }\n        </Geographies>\n\n        {/* Render country names and white rectangles on top */}\n        <Geographies geography={feature(worldCountries, worldCountries.objects.countries)}>\n          {({ geographies, projection }) =>\n            geographies.map((geo) => {\n              const countryColor = countryColors[geo.properties.name];\n\n              // Skip rendering names for yellow, grey, or the destination country\n              if (\n                !countryColor || // Skip unguessed countries\n                countryColor === '#f1c232' || // Yellow\n                countryColor === '#808080' || // Grey\n                (destinationCountry && geo.properties.name === destinationCountry.properties.name) // Destination country\n              ) {\n                return null;\n              }\n\n              const centroid = geoCentroid(geo); // Calculate the centroid of the country\n              const [x, y] = projection(centroid); // Convert geographic coordinates to screen coordinates\n\n              return (\n                <React.Fragment key={geo.rsmKey}>\n                  {/* Render a white rectangle behind the text */}\n                  <rect\n                    x={x - geo.properties.name.length - 2} // Reduce padding on the left\n                    y={y} // Reduce padding on the top\n                    width={geo.properties.name.length * 2 + 4} // Reduce overall width\n                    height={6} // Reduce height\n                    fill=\"white\"\n                    rx={3} // Slightly smaller rounded corners\n                    ry={3}\n                    style={{\n                      pointerEvents: 'none', // Ensure the rectangle doesn't block clicks\n                    }}\n                  />\n                  {/* Render the country name */}\n                  <text\n                    x={x}\n                    y={y + 4} // Adjust to vertically center the text\n                    textAnchor=\"middle\"\n                    style={{\n                      fontFamily: 'Arial, sans-serif',\n                      fontSize: 10 / zoomCenter.zoom, // Adjust font size inversely to zoom\n                      fill: '#000',\n                      pointerEvents: 'none', // Ensure the text doesn't block clicks\n                    }}\n                  >\n                    {geo.properties.name}\n                  </text>\n                </React.Fragment>\n              );\n            })\n          }\n        </Geographies>\n      </ZoomableGroup>\n    </ComposableMap>\n  );\n};\n\nexport default Map;","export default __webpack_public_path__ + \"static/media/background.7a582ea4.png\";","import React from 'react';\nimport background from '../assets/background.png';\n\nfunction StartScreen({ onStart }) {\n    return (\n        <div style={{\n            display: 'flex',\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            height: '100vh',\n            width: '100vw',\n            backgroundImage: `url(${background})`,\n            backgroundSize: 'cover',\n            backgroundPosition: 'center',\n        }}>\n            <button\n                style={{\n                    backgroundColor: 'red',\n                    color: 'white',\n                    fontSize: '2rem',\n                    padding: '1rem 3rem',\n                    border: 'none',\n                    borderRadius: '8px',\n                    cursor: 'pointer',\n                }}\n                onClick={onStart}\n            >\n                START\n            </button>\n        </div>\n    );\n}\n\nexport default StartScreen;\n","import React, { useState } from 'react';\nimport Map from './components/Map';\nimport StartScreen from './components/StartScreen';\n\nfunction App() {\n  const [started, setStarted] = useState(false);\n\n  return (\n    <div className=\"App\">\n      {!started ? (\n        <StartScreen onStart={() => setStarted(true)} />\n      ) : (\n        <Map />\n      )}\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}